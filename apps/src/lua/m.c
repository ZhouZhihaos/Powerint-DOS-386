/*
* one.c -- Lua core, libraries, and interpreter in a single file
*/

/* default is to build the full interpreter */
#ifndef MAKE_LIB
#ifndef MAKE_LUAC
#ifndef MAKE_LUA
#define MAKE_LUA
#endif
#endif
#endif

/* choose suitable platform-specific features */
/* some of these may need extra libraries such as -ldl -lreadline -lncurses */
#if 0
#define LUA_USE_LINUX
#define LUA_USE_MACOSX
#define LUA_USE_POSIX
#define LUA_ANSI
#endif

/* no need to change anything below this line ----------------------------- */

#include "lprefix.h"

#include <assert.h>
#include <ctype.h>
#include <float.h>
#include <limits.h>
#include <locale.h>
#include <math.h>
#include <setjmp.h>
#include <stdarg.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syscall.h>
#include <rand.h>
/* setup for luaconf.h */
#define LUA_CORE
#define LUA_LIB
#define ltable_c
#define lvm_c
#include "luaconf.h"

/* do not export internal symbols */
#undef LUAI_FUNC
#undef LUAI_DDEC
#undef LUAI_DDEF
#define LUAI_FUNC	static
#define LUAI_DDEC(def)	/* empty */
#define LUAI_DDEF	static

/* core -- used by all */
#include "lzio.c"
#include "lctype.c"
#include "lopcodes.c"
#include "lmem.c"
#include "lundump.c"
#include "ldump.c"
#include "lstate.c"
#include "lgc.c"
#include "llex.c"
#include "lcode.c"
#include "lparser.c"
#include "ldebug.c"
#include "lfunc.c"
#include "lobject.c"
#include "ltm.c"
#include "lstring.c"
#include "ltable.c"
#include "ldo.c"
#include "lvm.c"
#include "lapi.c"

/* auxiliary library -- used by all */
#include "lauxlib.c"

/* standard library  -- not used by luac */
#ifndef MAKE_LUAC
#include "lbaselib.c"
#include "lcorolib.c"
#include "ldblib.c"
#include "lmathlib.c"
#include "loadlib.c"
#include "lstrlib.c"
#include "ltablib.c"
#include "lutf8lib.c"
#include "liolib.c"
#include "linit.c"
#endif

/* lua */
#ifdef MAKE_LUA
/*
** $Id: lua.c $
** Lua stand-alone interpreter
** See Copyright Notice in lua.h
*/

#define lua_c

#include "lprefix.h"


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


#include "lua.h"

#include "lauxlib.h"
#include "lualib.h"


#if !defined(LUA_PROGNAME)
#define LUA_PROGNAME		"lua"
#endif

#if !defined(LUA_INIT_VAR)
#define LUA_INIT_VAR		"LUA_INIT"
#endif

#define LUA_INITVARVERSION	LUA_INIT_VAR LUA_VERSUFFIX
#define lua_stdin_is_tty()	1

static lua_State *globalL = NULL;

static const char *progname = LUA_PROGNAME;





static void print_usage (const char *badoption) {
  lua_writestringerror("%s: ", progname);
  if (badoption[1] == 'e' || badoption[1] == 'l')
    lua_writestringerror("'%s' needs argument\n", badoption);
  else
    lua_writestringerror("unrecognized option '%s'\n", badoption);
  lua_writestringerror(
  "usage: %s [options] [script [args]]\n"
  "Available options are:\n"
  "  -e stat   execute string 'stat'\n"
  "  -i        enter interactive mode after executing 'script'\n"
  "  -l mod    require library 'mod' into global 'mod'\n"
  "  -l g=mod  require library 'mod' into global 'g'\n"
  "  -v        show version information\n"
  "  -E        ignore environment variables\n"
  "  -W        turn warnings on\n"
  "  --        stop handling options\n"
  "  -         stop handling options and execute stdin\n"
  ,
  progname);
}


/*
** Prints an error message, adding the program name in front of it
** (if present)
*/
static void l_message (const char *pname, const char *msg) {
  if (pname) lua_writestringerror("%s: ", pname);
  lua_writestringerror("%s\n", msg);
}


/*
** Check whether 'status' is not OK and, if so, prints the error
** message on the top of the stack. It assumes that the error object
** is a string, as it was either generated by Lua or by 'msghandler'.
*/
static int report (lua_State *L, int status) {
  if (status != LUA_OK) {
    const char *msg = lua_tostring(L, -1);
    l_message(progname, msg);
    lua_pop(L, 1);  /* remove message */
  }
  return status;
}


/*
** Message handler used to run all chunks
*/
static int msghandler (lua_State *L) {
  const char *msg = lua_tostring(L, 1);
  if (msg == NULL) {  /* is error object not a string? */
    if (luaL_callmeta(L, 1, "__tostring") &&  /* does it have a metamethod */
        lua_type(L, -1) == LUA_TSTRING)  /* that produces a string? */
      return 1;  /* that is the message */
    else
      msg = lua_pushfstring(L, "(error object is a %s value)",
                               luaL_typename(L, 1));
  }
  luaL_traceback(L, L, msg, 1);  /* append a standard traceback */
  return 1;  /* return the traceback */
}


/*
** Interface to 'lua_pcall', which sets appropriate message function
** and C-signal handler. Used to run all chunks.
*/
static int docall (lua_State *L, int narg, int nres) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, msghandler);  /* push message handler */
  lua_insert(L, base);  /* put it under function and args */
  globalL = L;  /* to be available to 'laction' */
  status = lua_pcall(L, narg, nres, base);
  lua_remove(L, base);  /* remove message handler from the stack */
  return status;
}


static void print_version (void) {
  lua_writestring(LUA_COPYRIGHT, strlen(LUA_COPYRIGHT));
  lua_writeline();
}


/*
** Create the 'arg' table, which stores all arguments from the
** command line ('argv'). It should be aligned so that, at index 0,
** it has 'argv[script]', which is the script name. The arguments
** to the script (everything after 'script') go to positive indices;
** other arguments (before the script name) go to negative indices.
** If there is no script name, assume interpreter's name as base.
** (If there is no interpreter's name either, 'script' is -1, so
** table sizes are zero.)
*/
static void createargtable (lua_State *L, char **argv, int argc, int script) {
  int i, narg;
  narg = argc - (script + 1);  /* number of positive indices */
  lua_createtable(L, narg, script + 1);
  for (i = 0; i < argc; i++) {
    lua_pushstring(L, argv[i]);
    lua_rawseti(L, -2, i - script);
  }
  lua_setglobal(L, "arg");
}


static int dochunk (lua_State *L, int status) {
  if (status == LUA_OK) status = docall(L, 0, 0);
  return report(L, status);
}


static int dofile (lua_State *L, const char *name) {
  return dochunk(L, luaL_loadfile(L, name));
}


static int dostring (lua_State *L, const char *s, const char *name) {
  return dochunk(L, luaL_loadbuffer(L, s, strlen(s), name));
}


/*
** Receives 'globname[=modname]' and runs 'globname = require(modname)'.
*/
static int dolibrary (lua_State *L, char *globname) {
  int status;
  char *modname = strchr(globname, '=');
  if (modname == NULL)  /* no explicit name? */
    modname = globname;  /* module name is equal to global name */
  else {
    *modname = '\0';  /* global name ends here */
    modname++;  /* module name starts after the '=' */
  }
  lua_getglobal(L, "require");
  lua_pushstring(L, modname);
  status = docall(L, 1, 1);  /* call 'require(modname)' */
  if (status == LUA_OK)
    lua_setglobal(L, globname);  /* globname = require(modname) */
  return report(L, status);
}


/*
** Push on the stack the contents of table 'arg' from 1 to #arg
*/
static int pushargs (lua_State *L) {
  int i, n;
  if (lua_getglobal(L, "arg") != LUA_TTABLE)
    luaL_error(L, "'arg' is not a table");
  n = (int)luaL_len(L, -1);
  luaL_checkstack(L, n + 3, "too many arguments to script");
  for (i = 1; i <= n; i++)
    lua_rawgeti(L, -i, i);
  lua_remove(L, -i);  /* remove table from the stack */
  return n;
}


static int handle_script (lua_State *L, char **argv) {
  int status;
  const char *fname = argv[0];
  // printf("fname = %s\n",fname);
  if (strcmp(fname, "-") == 0 && strcmp(argv[-1], "--") != 0)
    fname = NULL;  /* stdin */
  status = luaL_loadfile(L, fname);
  if (status == LUA_OK) {
    int n = pushargs(L);  /* push arguments to script */
    status = docall(L, n, LUA_MULTRET);
  }
  return report(L, status);
}


/* bits of various argument indicators in 'args' */
#define has_error	1	/* bad option */
#define has_i		2	/* -i */
#define has_v		4	/* -v */
#define has_e		8	/* -e */
#define has_E		16	/* -E */


/*
** Traverses all arguments from 'argv', returning a mask with those
** needed before running any Lua code or an error code if it finds any
** invalid argument. In case of error, 'first' is the index of the bad
** argument.  Otherwise, 'first' is -1 if there is no program name,
** 0 if there is no script name, or the index of the script name.
*/
static int collectargs (char **argv, int *first) {
  int args = 0;
  int i;
  if (argv[0] != NULL) {  /* is there a program name? */
    if (argv[0][0])  /* not empty? */
      progname = argv[0];  /* save it */
  }
  else {  /* no program name */
    *first = -1;
    return 0;
  }
  for (i = 1; argv[i] != NULL; i++) {  /* handle arguments */
    *first = i;
    if (argv[i][0] != '-')  /* not an option? */
        return args;  /* stop handling options */
    switch (argv[i][1]) {  /* else check option */
      case '-':  /* '--' */
        if (argv[i][2] != '\0')  /* extra characters after '--'? */
          return has_error;  /* invalid option */
        *first = i + 1;
        return args;
      case '\0':  /* '-' */
        return args;  /* script "name" is '-' */
      case 'E':
        if (argv[i][2] != '\0')  /* extra characters? */
          return has_error;  /* invalid option */
        args |= has_E;
        break;
      case 'W':
        if (argv[i][2] != '\0')  /* extra characters? */
          return has_error;  /* invalid option */
        break;
      case 'i':
        args |= has_i;  /* (-i implies -v) *//* FALLTHROUGH */
      case 'v':
        if (argv[i][2] != '\0')  /* extra characters? */
          return has_error;  /* invalid option */
        args |= has_v;
        break;
      case 'e':
        args |= has_e;  /* FALLTHROUGH */
      case 'l':  /* both options need an argument */
        if (argv[i][2] == '\0') {  /* no concatenated argument? */
          i++;  /* try next 'argv' */
          if (argv[i] == NULL || argv[i][0] == '-')
            return has_error;  /* no next argument or it is another option */
        }
        break;
      default:  /* invalid option */
        return has_error;
    }
  }
  *first = 0;  /* no script name */
  return args;
}


/*
** Processes options 'e' and 'l', which involve running Lua code, and
** 'W', which also affects the state.
** Returns 0 if some code raises an error.
*/
static int runargs (lua_State *L, char **argv, int n) {
  int i;
  for (i = 1; i < n; i++) {
    int option = argv[i][1];
    lua_assert(argv[i][0] == '-');  /* already checked */
    switch (option) {
      case 'e':  case 'l': {
        int status;
        char *extra = argv[i] + 2;  /* both options need an argument */
        if (*extra == '\0') extra = argv[++i];
        lua_assert(extra != NULL);
        status = (option == 'e')
                 ? dostring(L, extra, "=(command line)")
                 : dolibrary(L, extra);
        if (status != LUA_OK) return 0;
        break;
      }
      case 'W':
        lua_warning(L, "@on", 0);  /* warnings on */
        break;
    }
  }
  return 1;
}


static int handle_luainit (lua_State *L) {
  
}


/*
** {==================================================================
** Read-Eval-Print Loop (REPL)
** ===================================================================
*/

#if !defined(LUA_PROMPT)
#define LUA_PROMPT		"> "
#define LUA_PROMPT2		">> "
#endif

#if !defined(LUA_MAXINPUT)
#define LUA_MAXINPUT		512
#endif




/*
** lua_readline defines how to show a prompt and then read a line from
** the standard input.
** lua_saveline defines how to "save" a read line in a "history".
** lua_freeline defines how to free a line read by lua_readline.
*/
#if !defined(lua_readline)	/* { */

#if defined(LUA_USE_READLINE)	/* { */

#include <readline/readline.h>
#include <readline/history.h>
#define lua_initreadline(L)	((void)L, rl_readline_name="lua")
#define lua_readline(L,b,p)	((void)L, ((b)=readline(p)) != NULL)
#define lua_saveline(L,line)	((void)L, add_history(line))
#define lua_freeline(L,b)	((void)L, free(b))

#else				/* }{ */

#define lua_initreadline(L)  ((void)L)
#define lua_readline(L,b,p) \
        ((void)L, fputs(p, stdout), fflush(stdout),  /* show prompt */ \
        fgets(b, LUA_MAXINPUT, stdin) != NULL)  /* get line */
#define lua_saveline(L,line)	{ (void)L; (void)line; }
#define lua_freeline(L,b)	{ (void)L; (void)b; }

#endif				/* } */

#endif				/* } */


/*
** Return the string to be used as a prompt by the interpreter. Leave
** the string (or nil, if using the default value) on the stack, to keep
** it anchored.
*/
static const char *get_prompt (lua_State *L, int firstline) {
  if (lua_getglobal(L, firstline ? "_PROMPT" : "_PROMPT2") == LUA_TNIL)
    return (firstline ? LUA_PROMPT : LUA_PROMPT2);  /* use the default */
  else {  /* apply 'tostring' over the value */
    const char *p = luaL_tolstring(L, -1, NULL);
    lua_remove(L, -2);  /* remove original value */
    return p;
  }
}

/* mark in error messages for incomplete statements */
#define EOFMARK		"<eof>"
#define marklen		(sizeof(EOFMARK)/sizeof(char) - 1)

static int lua_input(lua_State* L) {
  char* buf = malloc(100);
  scan(buf, 100);
  lua_pushstring(L, buf);
  free(buf);
  return 1;
}
static int num(lua_State* L) {
  // size_t l;
  // const char* s = lua_tolstring(L, 1, &l);
  printf("Hello!\n");
  lua_pushinteger(L, 1);
  return 1;
}
static int LSystem(lua_State* L) {
  // size_t l;
  size_t l;
  const char* s = lua_tolstring(L, 1, &l);
  system(s);
  return 0;
}
static int LSleep(lua_State* L) {
  // size_t l;
  int arg1 = lua_tointeger(L, 1);
  sleep(arg1);
  return 0;
}
static int Lsrand(lua_State* L) {
  mysrand(RAND());
  return 0;
}
static int lua_ReadFile(lua_State* L) {
  size_t l;
  const char* s = lua_tolstring(L, 1, &l);
  if(filesize(s) != -1) {
    char* buf = malloc(filesize(s) + 1);
    api_ReadFile(s,buf);
    lua_pushstring(L, buf);
    free(buf);
  } else {
    lua_pushstring(L, "");
  }
  return 1;
}
static int lua_Putstr(lua_State* L) {
  size_t l;
  const char* s = lua_tolstring(L, 1, &l);
  print(s);
  return 0;
}
static int lua_getch(lua_State* L) {
  lua_pushinteger(L,getch());
  return 1;
}
static int Lrand(lua_State* L) {
  int arg1 = lua_tointeger(L, 1);
  int arg2 = lua_tointeger(L, 2);
 // printf("arg1=%d,arg2=%d\n", arg1, arg2);
  lua_pushinteger(L, myrand() % arg2 + arg1);
  return 1;
}
static int lua_gotoxy(lua_State* L) {
  int arg1 = lua_tointeger(L, 1);
  int arg2 = lua_tointeger(L, 2);
  goto_xy(arg1,arg2);
  return 0;
}
static int lua_exit(lua_State* L) {
  exit();
  return 0;
}
static int lua_forever(lua_State* L) {
  TaskForever();
  return 0;
}
static int lua_ipcMessage(lua_State* L) {
  int mode = lua_tointeger(L,1);
  int tid = lua_tointeger(L,2);
  int data;
  GetMessage(&data,tid);
  if (mode == 0) {
    lua_pushinteger(L,data);
  } else if (mode == 1) {
    lua_pushnil(L);
  } else {
    lua_pushnil(L);
  }
  return 1;
}
static int lua_MessageLength(lua_State* L) {
  int tid = lua_tointeger(L,1);
  int result = MessageLength(tid);
 // printf("tid = %d result = %d\n",tid,result);
  lua_pushinteger(L,result);
  return 1;
}
static void ThreadHandler(lua_State *L) {
  printf("%08x\n",L);
  for(;;);
}
static int lua_Addthread(lua_State *L) {
  unsigned int *stack = (unsigned int *)(malloc(16*1024)+16*1024);
  stack[-1] = 0x12345678;
  AddThread ("Thread",ThreadHandler,(unsigned int)(stack) - 4);
  return 0;
}
static int LChr(lua_State* L) {
  char result[2] = {lua_tointeger(L,1),0};
  lua_pushstring(L,result);
  return 1;
}
static int Leval(lua_State* L) {
  char *retline = malloc(strlen(lua_tostring(L,1))+8);
  sprintf(retline,"return %s;",lua_tostring(L,1));
  luaL_loadbuffer(L, retline, strlen(retline), "eval");
  docall(L, 0, LUA_MULTRET);
  free(retline);
  return 1;
}
static int Lmod(lua_State* L) {
  if(filesize(lua_tostring(L,1)) == -1) {
    lua_pushfstring(L,"mod file(%s) not found",lua_tostring(L,1));
    lua_error(L);
    return 1;
  }
  luaL_loadfile(L, lua_tostring(L,1));
  docall(L, 0, LUA_MULTRET);
  return 1;
}
static const struct luaL_Reg my_lib_bsp[] = {{"input", lua_input},
                                             {"num", num},
                                             {"Srand", Lsrand},
                                             {"Rand", Lrand},
                                             {"exec", LSystem},
                                             {"sleep", LSleep},
                                             {"chr", LChr},
                                             {"eval",Leval},
                                             {"mod",Lmod},
                                             {NULL, NULL}};
static const struct luaL_Reg io_lib[] = {{"ReadFile", lua_ReadFile},
                                          {"putstr", lua_Putstr},
                                          {"getch", lua_getch},
                                          {"gotoxy", lua_gotoxy},
                                             {NULL, NULL}};
static const struct luaL_Reg os_lib[] = {{"exit", lua_exit},
                                         {"forever", lua_forever},
                                         {"GetIPCMessage", lua_ipcMessage}, // 传模式 1返回字符串 0就是int
                                         {"MessageLength", lua_MessageLength},
                                         {"AddThread",lua_Addthread},
                                         {NULL, NULL}};
/*
** Check whether 'status' signals a syntax error and the error
** message at the top of the stack ends with the above mark for
** incomplete statements.
*/
static int incomplete (lua_State *L, int status) {
  if (status == LUA_ERRSYNTAX) {
    size_t lmsg;
    const char *msg = lua_tolstring(L, -1, &lmsg);
    if (lmsg >= marklen && strcmp(msg + lmsg - marklen, EOFMARK) == 0) {
      lua_pop(L, 1);
      return 1;
    }
  }
  return 0;  /* else... */
}


/*
** Prompt the user, read a line, and push it into the Lua stack.
*/
static int pushline (lua_State *L, int firstline) {
  char buffer[LUA_MAXINPUT];
  char *b = buffer;
  size_t l;
  const char *prmt = get_prompt(L, firstline);
  int readstatus = lua_readline(L, b, prmt);
  if (readstatus == 0)
    return 0;  /* no input (prompt will be popped by caller) */
  lua_pop(L, 1);  /* remove prompt */
  l = strlen(b);
  if (l > 0 && b[l-1] == '\n')  /* line ends with newline? */
    b[--l] = '\0';  /* remove it */
  if (firstline && b[0] == '=')  /* for compatibility with 5.2, ... */
    lua_pushfstring(L, "return %s", b + 1);  /* change '=' to 'return' */
  else
    lua_pushlstring(L, b, l);
  lua_freeline(L, b);
  return 1;
}


/*
** Try to compile line on the stack as 'return <line>;'; on return, stack
** has either compiled chunk or original line (if compilation failed).
*/
static int addreturn (lua_State *L) {
  const char *line = lua_tostring(L, -1);  /* original line */
  const char *retline = lua_pushfstring(L, "return %s;", line);
  int status = luaL_loadbuffer(L, retline, strlen(retline), "=stdin");
  if (status == LUA_OK) {
    lua_remove(L, -2);  /* remove modified line */
    if (line[0] != '\0')  /* non empty? */
      lua_saveline(L, line);  /* keep history */
  }
  else
    lua_pop(L, 2);  /* pop result from 'luaL_loadbuffer' and modified line */
  return status;
}


/*
** Read multiple lines until a complete Lua statement
*/
static int multiline (lua_State *L) {
  for (;;) {  /* repeat until gets a complete statement */
    size_t len;
    const char *line = lua_tolstring(L, 1, &len);  /* get what it has */
    int status = luaL_loadbuffer(L, line, len, "=stdin");  /* try it */
    if (!incomplete(L, status) || !pushline(L, 0)) {
      lua_saveline(L, line);  /* keep history */
      return status;  /* cannot or should not try to add continuation line */
    }
    lua_pushliteral(L, "\n");  /* add newline... */
    lua_insert(L, -2);  /* ...between the two lines */
    lua_concat(L, 3);  /* join them */
  }
}


/*
** Read a line and try to load (compile) it first as an expression (by
** adding "return " in front of it) and second as a statement. Return
** the final status of load/call with the resulting function (if any)
** in the top of the stack.
*/
static int loadline (lua_State *L) {
  int status;
  lua_settop(L, 0);
  if (!pushline(L, 1))
    return -1;  /* no input */
  if ((status = addreturn(L)) != LUA_OK)  /* 'return ...' did not work? */
    status = multiline(L);  /* try as command, maybe with continuation lines */
  lua_remove(L, 1);  /* remove line from the stack */
  lua_assert(lua_gettop(L) == 1);
  return status;
}


/*
** Prints (calling the Lua 'print' function) any values on the stack
*/
static void l_print (lua_State *L) {
  int n = lua_gettop(L);
  if (n > 0) {  /* any result to be printed? */
    luaL_checkstack(L, LUA_MINSTACK, "too many results to print");
    lua_getglobal(L, "print");
    lua_insert(L, 1);
    if (lua_pcall(L, n, 0, 0) != LUA_OK)
      l_message(progname, lua_pushfstring(L, "error calling 'print' (%s)",
                                             lua_tostring(L, -1)));
  }
}


/*
** Do the REPL: repeatedly read (load) a line, evaluate (call) it, and
** print any results.
*/
static void doREPL (lua_State *L) {
  int status;
  const char *oldprogname = progname;
  progname = NULL;  /* no 'progname' on errors in interactive mode */
  lua_initreadline(L);
  while ((status = loadline(L)) != -1) {
    if (status == LUA_OK)
      status = docall(L, 0, LUA_MULTRET);
    if (status == LUA_OK) l_print(L);
    else report(L, status);
  }
  lua_settop(L, 0);  /* clear stack */
  lua_writeline();
  progname = oldprogname;
}

/* }================================================================== */

static int open_io(lua_State* L) {
  luaL_newlib(L,io_lib);
  return 1;
}
static int open_os(lua_State* L) {
  luaL_newlib(L,os_lib);
  return 1;
}
/*
** Main body of stand-alone interpreter (to be called in protected mode).
** Reads the options and handles them all.
*/
static int pmain (lua_State *L) {
 // printf("pmain\n");
  int argc = (int)lua_tointeger(L, 1);
  char **argv = (char **)lua_touserdata(L, 2);
  int script;
  int args = collectargs(argv, &script);
  int optlim = (script > 0) ? script : argc; /* first argv not an option */
  luaL_checkversion(L);  /* check that interpreter has correct version */
  if (args == has_error) {  /* bad arg? */
    print_usage(argv[script]);  /* 'script' has index of bad arg. */
    return 0;
  }
  if (args & has_v)  /* option '-v'? */
    print_version();
  if (args & has_E) {  /* option '-E'? */
    lua_pushboolean(L, 1);  /* signal for libraries to ignore env. vars. */
    lua_setfield(L, LUA_REGISTRYINDEX, "LUA_NOENV");
  }
 // printf("In this2\n");
  luaopen_base(L);
  luaL_setfuncs(L, my_lib_bsp, 0);
  luaL_requiref(L, "pio", open_io, 1);
  luaL_requiref(L, "os", open_os, 1);
  luaL_openlibs(L);  /* open standard libraries */
  createargtable(L, argv, argc, script);  /* create table 'arg' */
  lua_gc(L, LUA_GCGEN, 0, 0);  /* GC in generational mode */
  if (!(args & has_E)) {  /* no option '-E'? */
  }
  if (!runargs(L, argv, optlim))  /* execute arguments -e and -l */
    return 0;  /* something failed */
  if (script > 0) {  /* execute main script (if there is one) */
    if (handle_script(L, argv + script) != LUA_OK)
      return 0;  /* interrupt in case of error */
  }
 // printf("In this1\n");
  if (args & has_i)  /* -i option? */
    doREPL(L);  /* do read-eval-print loop */
  else if (script < 1 && !(args & (has_e | has_v))) { /* no active option? */
    
    if (lua_stdin_is_tty()) {  /* running in interactive mode? */
      print_version();
      doREPL(L);  /* do read-eval-print loop */
    }
    else dofile(L, NULL);  /* executes stdin as a file */
  }
  lua_pushboolean(L, 1);  /* signal no errors */
  return 1;
}


int main (int argc, char **argv) {
  int status, result;
  lua_State *L = luaL_newstate();  /* create state */
  if (L == NULL) {
    l_message(argv[0], "cannot create state: not enough memory");
    return 1;
  }
  lua_pushcfunction(L, &pmain);  /* to call 'pmain' in protected mode */
  lua_pushinteger(L, argc);  /* 1st argument */
  lua_pushlightuserdata(L, argv); /* 2nd argument */
  status = lua_pcall(L, 2, 1, 0);  /* do the call */
  result = lua_toboolean(L, -1);  /* get result */
  report(L, status);
  lua_close(L);
  return (result && status == LUA_OK) ? 0 : 1;
}


#endif
#ifdef MAKE_LUAC
/*
** $Id: luac.c $
** Lua compiler (saves bytecodes to files; also lists bytecodes)
** See Copyright Notice in lua.h
*/

#define luac_c
#define LUA_CORE
/*
** $Id: luac.c $
** Lua compiler (saves bytecodes to files; also lists bytecodes)
** See Copyright Notice in lua.h
*/

#define luac_c
#define LUA_CORE

#include "lprefix.h"

#include <ctype.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "lua.h"
#include "lauxlib.h"

#include "ldebug.h"
#include "lobject.h"
#include "lopcodes.h"
#include "lopnames.h"
#include "lstate.h"
#include "lundump.h"

static void PrintFunction(const Proto* f, int full);
#define luaU_print  PrintFunction

#define PROGNAME  "luac"    /* default program name */
#define OUTPUT    PROGNAME ".out" /* default output file */

static int listing=0;     /* list bytecodes? */
static int dumping=1;     /* dump bytecodes? */
static int stripping=0;     /* strip debug information? */
static char Output[]={ OUTPUT };  /* default output file name */
static const char* output=Output; /* actual output file name */
static const char* progname=PROGNAME; /* actual program name */
static TString **tmname;

static void fatal(const char* message)
{
 fprintf(stderr,"%s: %s\n",progname,message);
 exit();
}

static void cannot(const char* what)
{
 fprintf(stderr,"%s: cannot %s %s: %s\n",progname,what,output,strerror(errno));
 exit();
}

static void usage(const char* message)
{
 if (*message=='-')
  fprintf(stderr,"%s: unrecognized option '%s'\n",progname,message);
 else
  fprintf(stderr,"%s: %s\n",progname,message);
 fprintf(stderr,
  "usage: %s [options] [filenames]\n"
  "Available options are:\n"
  "  -l       list (use -l -l for full listing)\n"
  "  -o name  output to file 'name' (default is \"%s\")\n"
  "  -p       parse only\n"
  "  -s       strip debug information\n"
  "  -v       show version information\n"
  "  --       stop handling options\n"
  "  -        stop handling options and process stdin\n"
  ,progname,Output);
 exit();
}

#define IS(s) (strcmp(argv[i],s)==0)

static int doargs(int argc, char* argv[])
{
 int i;
 int version=0;
 if (argv[0]!=NULL && *argv[0]!=0) progname=argv[0];
 for (i=1; i<argc; i++)
 {
  if (*argv[i]!='-')      /* end of options; keep it */
   break;
  else if (IS("--"))      /* end of options; skip it */
  {
   ++i;
   if (version) ++version;
   break;
  }
  else if (IS("-"))     /* end of options; use stdin */
   break;
  else if (IS("-l"))      /* list */
   ++listing;
  else if (IS("-o"))      /* output file */
  {
   output=argv[++i];
   if (output==NULL || *output==0 || (*output=='-' && output[1]!=0))
    usage("'-o' needs argument");
   if (IS("-")) output=NULL;
  }
  else if (IS("-p"))      /* parse only */
   dumping=0;
  else if (IS("-s"))      /* strip debug information */
   stripping=1;
  else if (IS("-v"))      /* show version */
   ++version;
  else          /* unknown option */
   usage(argv[i]);
 }
 if (i==argc && (listing || !dumping))
 {
  dumping=0;
  argv[--i]=Output;
 }
 if (version)
 {
  printf("%s\n",LUA_COPYRIGHT);
  if (version==argc-1) exit();
 }
 return i;
}

#define FUNCTION "(function()end)();"

static const char* reader(lua_State* L, void* ud, size_t* size)
{
 UNUSED(L);
 if ((*(int*)ud)--)
 {
  *size=sizeof(FUNCTION)-1;
  return FUNCTION;
 }
 else
 {
  *size=0;
  return NULL;
 }
}

#define toproto(L,i) getproto(s2v(L->top+(i)))

static const Proto* combine(lua_State* L, int n)
{
 if (n==1)
  return toproto(L,-1);
 else
 {
  Proto* f;
  int i=n;
  if (lua_load(L,reader,&i,"=(" PROGNAME ")",NULL)!=LUA_OK) fatal(lua_tostring(L,-1));
  f=toproto(L,-1);
  for (i=0; i<n; i++)
  {
   f->p[i]=toproto(L,i-n-1);
   if (f->p[i]->sizeupvalues>0) f->p[i]->upvalues[0].instack=0;
  }
  luaM_freearray(L,f->lineinfo,f->sizelineinfo);
  f->sizelineinfo=0;
  return f;
 }
}

static int writer(lua_State* L, const void* p, size_t size, void* u)
{
 UNUSED(L);
 return (fwrite(p,size,1,(FILE*)u)!=1) && (size!=0);
}

static int pmain(lua_State* L)
{
 int argc=(int)lua_tointeger(L,1);
 char** argv=(char**)lua_touserdata(L,2);
 const Proto* f;
 int i;
 tmname=G(L)->tmname;
 if (!lua_checkstack(L,argc)) fatal("too many input files");
 for (i=0; i<argc; i++)
 {
  const char* filename=IS("-") ? NULL : argv[i];
  if (luaL_loadfile(L,filename)!=LUA_OK) fatal(lua_tostring(L,-1));
 }
 f=combine(L,argc);
 if (listing) luaU_print(f,listing>1);
 if (dumping)
 {
  FILE* D= (output==NULL) ? stdout : fopen(output,"wb");
  if (D==NULL) cannot("open");
  lua_lock(L);
  luaU_dump(L,f,writer,D,stripping);
  lua_unlock(L);
  if (ferror(D)) cannot("write");
  if (fclose(D)) cannot("close");
 }
 return 0;
}

int main(int argc, char* argv[])
{
 lua_State* L;
 int i=doargs(argc,argv);
 argc-=i; argv+=i;
 if (argc<=0) usage("no input files given");
 L=luaL_newstate();
 if (L==NULL) fatal("cannot create state: not enough memory");
 lua_pushcfunction(L,&pmain);
 lua_pushinteger(L,argc);
 lua_pushlightuserdata(L,argv);
 if (lua_pcall(L,2,0,0)!=LUA_OK) fatal(lua_tostring(L,-1));
 lua_close(L);
 return 0;
}

/*
** print bytecodes
*/

#define UPVALNAME(x) ((f->upvalues[x].name) ? getstr(f->upvalues[x].name) : "-")
#define VOID(p) ((const void*)(p))
#define eventname(i) (getstr(tmname[i]))

static void PrintString(const TString* ts)
{
 const char* s=getstr(ts);
 size_t i,n=tsslen(ts);
 printf("\"");
 for (i=0; i<n; i++)
 {
  int c=(int)(unsigned char)s[i];
  switch (c)
  {
   case '"':
  printf("\\\"");
  break;
   case '\\':
  printf("\\\\");
  break;
   case '\a':
  printf("\\a");
  break;
   case '\b':
  printf("\\b");
  break;
   case '\f':
  printf("\\f");
  break;
   case '\n':
  printf("\\n");
  break;
   case '\r':
  printf("\\r");
  break;
   case '\t':
  printf("\\t");
  break;
   case '\v':
  printf("\\v");
  break;
   default:
  if (isprint(c)) printf("%c",c); else printf("\\%03d",c);
  break;
  }
 }
 printf("\"");
}

static void PrintType(const Proto* f, int i)
{
 const TValue* o=&f->k[i];
 switch (ttypetag(o))
 {
  case LUA_VNIL:
  printf("N");
  break;
  case LUA_VFALSE:
  case LUA_VTRUE:
  printf("B");
  break;
  case LUA_VNUMFLT:
  printf("F");
  break;
  case LUA_VNUMINT:
  printf("I");
  break;
  case LUA_VSHRSTR:
  case LUA_VLNGSTR:
  printf("S");
  break;
  default:        /* cannot happen */
  printf("?%d",ttypetag(o));
  break;
 }
 printf("\t");
}

static void PrintConstant(const Proto* f, int i)
{
 const TValue* o=&f->k[i];
 switch (ttypetag(o))
 {
  case LUA_VNIL:
  printf("nil");
  break;
  case LUA_VFALSE:
  printf("false");
  break;
  case LUA_VTRUE:
  printf("true");
  break;
  case LUA_VNUMFLT:
  {
  char buff[100];
  sprintf(buff,LUA_NUMBER_FMT,fltvalue(o));
  printf("%s",buff);
  if (buff[strspn(buff,"-0123456789")]=='\0') printf(".0");
  break;
  }
  case LUA_VNUMINT:
  printf(LUA_INTEGER_FMT,ivalue(o));
  break;
  case LUA_VSHRSTR:
  case LUA_VLNGSTR:
  PrintString(tsvalue(o));
  break;
  default:        /* cannot happen */
  printf("?%d",ttypetag(o));
  break;
 }
}

#define COMMENT   "\t; "
#define EXTRAARG  GETARG_Ax(code[pc+1])
#define EXTRAARGC (EXTRAARG*(MAXARG_C+1))
#define ISK   (isk ? "k" : "")

static void PrintCode(const Proto* f)
{
 const Instruction* code=f->code;
 int pc,n=f->sizecode;
 for (pc=0; pc<n; pc++)
 {
  Instruction i=code[pc];
  OpCode o=GET_OPCODE(i);
  int a=GETARG_A(i);
  int b=GETARG_B(i);
  int c=GETARG_C(i);
  int ax=GETARG_Ax(i);
  int bx=GETARG_Bx(i);
  int sb=GETARG_sB(i);
  int sc=GETARG_sC(i);
  int sbx=GETARG_sBx(i);
  int isk=GETARG_k(i);
  int line=luaG_getfuncline(f,pc);
  printf("\t%d\t",pc+1);
  if (line>0) printf("[%d]\t",line); else printf("[-]\t");
  printf("%-9s\t",opnames[o]);
  switch (o)
  {
   case OP_MOVE:
  printf("%d %d",a,b);
  break;
   case OP_LOADI:
  printf("%d %d",a,sbx);
  break;
   case OP_LOADF:
  printf("%d %d",a,sbx);
  break;
   case OP_LOADK:
  printf("%d %d",a,bx);
  printf(COMMENT); PrintConstant(f,bx);
  break;
   case OP_LOADKX:
  printf("%d",a);
  printf(COMMENT); PrintConstant(f,EXTRAARG);
  break;
   case OP_LOADFALSE:
  printf("%d",a);
  break;
   case OP_LFALSESKIP:
  printf("%d",a);
  break;
   case OP_LOADTRUE:
  printf("%d",a);
  break;
   case OP_LOADNIL:
  printf("%d %d",a,b);
  printf(COMMENT "%d out",b+1);
  break;
   case OP_GETUPVAL:
  printf("%d %d",a,b);
  printf(COMMENT "%s",UPVALNAME(b));
  break;
   case OP_SETUPVAL:
  printf("%d %d",a,b);
  printf(COMMENT "%s",UPVALNAME(b));
  break;
   case OP_GETTABUP:
  printf("%d %d %d",a,b,c);
  printf(COMMENT "%s",UPVALNAME(b));
  printf(" "); PrintConstant(f,c);
  break;
   case OP_GETTABLE:
  printf("%d %d %d",a,b,c);
  break;
   case OP_GETI:
  printf("%d %d %d",a,b,c);
  break;
   case OP_GETFIELD:
  printf("%d %d %d",a,b,c);
  printf(COMMENT); PrintConstant(f,c);
  break;
   case OP_SETTABUP:
  printf("%d %d %d%s",a,b,c,ISK);
  printf(COMMENT "%s",UPVALNAME(a));
  printf(" "); PrintConstant(f,b);
  if (isk) { printf(" "); PrintConstant(f,c); }
  break;
   case OP_SETTABLE:
  printf("%d %d %d%s",a,b,c,ISK);
  if (isk) { printf(COMMENT); PrintConstant(f,c); }
  break;
   case OP_SETI:
  printf("%d %d %d%s",a,b,c,ISK);
  if (isk) { printf(COMMENT); PrintConstant(f,c); }
  break;
   case OP_SETFIELD:
  printf("%d %d %d%s",a,b,c,ISK);
  printf(COMMENT); PrintConstant(f,b);
  if (isk) { printf(" "); PrintConstant(f,c); }
  break;
   case OP_NEWTABLE:
  printf("%d %d %d",a,b,c);
  printf(COMMENT "%d",c+EXTRAARGC);
  break;
   case OP_SELF:
  printf("%d %d %d%s",a,b,c,ISK);
  if (isk) { printf(COMMENT); PrintConstant(f,c); }
  break;
   case OP_ADDI:
  printf("%d %d %d",a,b,sc);
  break;
   case OP_ADDK:
  printf("%d %d %d",a,b,c);
  printf(COMMENT); PrintConstant(f,c);
  break;
   case OP_SUBK:
  printf("%d %d %d",a,b,c);
  printf(COMMENT); PrintConstant(f,c);
  break;
   case OP_MULK:
  printf("%d %d %d",a,b,c);
  printf(COMMENT); PrintConstant(f,c);
  break;
   case OP_MODK:
  printf("%d %d %d",a,b,c);
  printf(COMMENT); PrintConstant(f,c);
  break;
   case OP_POWK:
  printf("%d %d %d",a,b,c);
  printf(COMMENT); PrintConstant(f,c);
  break;
   case OP_DIVK:
  printf("%d %d %d",a,b,c);
  printf(COMMENT); PrintConstant(f,c);
  break;
   case OP_IDIVK:
  printf("%d %d %d",a,b,c);
  printf(COMMENT); PrintConstant(f,c);
  break;
   case OP_BANDK:
  printf("%d %d %d",a,b,c);
  printf(COMMENT); PrintConstant(f,c);
  break;
   case OP_BORK:
  printf("%d %d %d",a,b,c);
  printf(COMMENT); PrintConstant(f,c);
  break;
   case OP_BXORK:
  printf("%d %d %d",a,b,c);
  printf(COMMENT); PrintConstant(f,c);
  break;
   case OP_SHRI:
  printf("%d %d %d",a,b,sc);
  break;
   case OP_SHLI:
  printf("%d %d %d",a,b,sc);
  break;
   case OP_ADD:
  printf("%d %d %d",a,b,c);
  break;
   case OP_SUB:
  printf("%d %d %d",a,b,c);
  break;
   case OP_MUL:
  printf("%d %d %d",a,b,c);
  break;
   case OP_MOD:
  printf("%d %d %d",a,b,c);
  break;
   case OP_POW:
  printf("%d %d %d",a,b,c);
  break;
   case OP_DIV:
  printf("%d %d %d",a,b,c);
  break;
   case OP_IDIV:
  printf("%d %d %d",a,b,c);
  break;
   case OP_BAND:
  printf("%d %d %d",a,b,c);
  break;
   case OP_BOR:
  printf("%d %d %d",a,b,c);
  break;
   case OP_BXOR:
  printf("%d %d %d",a,b,c);
  break;
   case OP_SHL:
  printf("%d %d %d",a,b,c);
  break;
   case OP_SHR:
  printf("%d %d %d",a,b,c);
  break;
   case OP_MMBIN:
  printf("%d %d %d",a,b,c);
  printf(COMMENT "%s",eventname(c));
  break;
   case OP_MMBINI:
  printf("%d %d %d %d",a,sb,c,isk);
  printf(COMMENT "%s",eventname(c));
  if (isk) printf(" flip");
  break;
   case OP_MMBINK:
  printf("%d %d %d %d",a,b,c,isk);
  printf(COMMENT "%s ",eventname(c)); PrintConstant(f,b);
  if (isk) printf(" flip");
  break;
   case OP_UNM:
  printf("%d %d",a,b);
  break;
   case OP_BNOT:
  printf("%d %d",a,b);
  break;
   case OP_NOT:
  printf("%d %d",a,b);
  break;
   case OP_LEN:
  printf("%d %d",a,b);
  break;
   case OP_CONCAT:
  printf("%d %d",a,b);
  break;
   case OP_CLOSE:
  printf("%d",a);
  break;
   case OP_TBC:
  printf("%d",a);
  break;
   case OP_JMP:
  printf("%d",GETARG_sJ(i));
  printf(COMMENT "to %d",GETARG_sJ(i)+pc+2);
  break;
   case OP_EQ:
  printf("%d %d %d",a,b,isk);
  break;
   case OP_LT:
  printf("%d %d %d",a,b,isk);
  break;
   case OP_LE:
  printf("%d %d %d",a,b,isk);
  break;
   case OP_EQK:
  printf("%d %d %d",a,b,isk);
  printf(COMMENT); PrintConstant(f,b);
  break;
   case OP_EQI:
  printf("%d %d %d",a,sb,isk);
  break;
   case OP_LTI:
  printf("%d %d %d",a,sb,isk);
  break;
   case OP_LEI:
  printf("%d %d %d",a,sb,isk);
  break;
   case OP_GTI:
  printf("%d %d %d",a,sb,isk);
  break;
   case OP_GEI:
  printf("%d %d %d",a,sb,isk);
  break;
   case OP_TEST:
  printf("%d %d",a,isk);
  break;
   case OP_TESTSET:
  printf("%d %d %d",a,b,isk);
  break;
   case OP_CALL:
  printf("%d %d %d",a,b,c);
  printf(COMMENT);
  if (b==0) printf("all in "); else printf("%d in ",b-1);
  if (c==0) printf("all out"); else printf("%d out",c-1);
  break;
   case OP_TAILCALL:
  printf("%d %d %d%s",a,b,c,ISK);
  printf(COMMENT "%d in",b-1);
  break;
   case OP_RETURN:
  printf("%d %d %d%s",a,b,c,ISK);
  printf(COMMENT);
  if (b==0) printf("all out"); else printf("%d out",b-1);
  break;
   case OP_RETURN0:
  break;
   case OP_RETURN1:
  printf("%d",a);
  break;
   case OP_FORLOOP:
  printf("%d %d",a,bx);
  printf(COMMENT "to %d",pc-bx+2);
  break;
   case OP_FORPREP:
  printf("%d %d",a,bx);
  printf(COMMENT "exit to %d",pc+bx+3);
  break;
   case OP_TFORPREP:
  printf("%d %d",a,bx);
  printf(COMMENT "to %d",pc+bx+2);
  break;
   case OP_TFORCALL:
  printf("%d %d",a,c);
  break;
   case OP_TFORLOOP:
  printf("%d %d",a,bx);
  printf(COMMENT "to %d",pc-bx+2);
  break;
   case OP_SETLIST:
  printf("%d %d %d",a,b,c);
  if (isk) printf(COMMENT "%d",c+EXTRAARGC);
  break;
   case OP_CLOSURE:
  printf("%d %d",a,bx);
  printf(COMMENT "%p",VOID(f->p[bx]));
  break;
   case OP_VARARG:
  printf("%d %d",a,c);
  printf(COMMENT);
  if (c==0) printf("all out"); else printf("%d out",c-1);
  break;
   case OP_VARARGPREP:
  printf("%d",a);
  break;
   case OP_EXTRAARG:
  printf("%d",ax);
  break;
#if 0
   default:
  printf("%d %d %d",a,b,c);
  printf(COMMENT "not handled");
  break;
#endif
  }
  printf("\n");
 }
}


#define SS(x) ((x==1)?"":"s")
#define S(x)  (int)(x),SS(x)

static void PrintHeader(const Proto* f)
{
 const char* s=f->source ? getstr(f->source) : "=?";
 if (*s=='@' || *s=='=')
  s++;
 else if (*s==LUA_SIGNATURE[0])
  s="(bstring)";
 else
  s="(string)";
 printf("\n%s <%s:%d,%d> (%d instruction%s at %p)\n",
  (f->linedefined==0)?"main":"function",s,
  f->linedefined,f->lastlinedefined,
  S(f->sizecode),VOID(f));
 printf("%d%s param%s, %d slot%s, %d upvalue%s, ",
  (int)(f->numparams),f->is_vararg?"+":"",SS(f->numparams),
  S(f->maxstacksize),S(f->sizeupvalues));
 printf("%d local%s, %d constant%s, %d function%s\n",
  S(f->sizelocvars),S(f->sizek),S(f->sizep));
}

static void PrintDebug(const Proto* f)
{
 int i,n;
 n=f->sizek;
 printf("constants (%d) for %p:\n",n,VOID(f));
 for (i=0; i<n; i++)
 {
  printf("\t%d\t",i);
  PrintType(f,i);
  PrintConstant(f,i);
  printf("\n");
 }
 n=f->sizelocvars;
 printf("locals (%d) for %p:\n",n,VOID(f));
 for (i=0; i<n; i++)
 {
  printf("\t%d\t%s\t%d\t%d\n",
  i,getstr(f->locvars[i].varname),f->locvars[i].startpc+1,f->locvars[i].endpc+1);
 }
 n=f->sizeupvalues;
 printf("upvalues (%d) for %p:\n",n,VOID(f));
 for (i=0; i<n; i++)
 {
  printf("\t%d\t%s\t%d\t%d\n",
  i,UPVALNAME(i),f->upvalues[i].instack,f->upvalues[i].idx);
 }
}

static void PrintFunction(const Proto* f, int full)
{
 int i,n=f->sizep;
 PrintHeader(f);
 PrintCode(f);
 if (full) PrintDebug(f);
 for (i=0; i<n; i++) PrintFunction(f->p[i],full);
}



#endif